In the process algebraic context [8, 16, 18], both specification and implementation may be represented as processes, and the notion that a process Q implements a process P is based on the idea that Q is more deterministic than (or equivalent to) P in terms of the chosen semantics.
We can partition the channels of a process P into the input channels, in P , and output channels, out P .
What we need is a more sophisticated device, which in our case comes in the form of another mapping, ref , constraining the possible refusals a process can exhibit, on channels which will be hidden in the composed system Q, after a given trace precisely, a sender process can admit a refusal disallowed by ref (t) if the extracted trace extr(t) admits in the target process the refusal of all communication on the corresponding channel and, moreover, the trace t itself is complete, i.e., t # dom.
The implementation relation Suppose that we intend to implement a base process P using another process Q with a possibly di#erent communication interface.
Finally, RE states a condition for refusal extraction, which means that if a trace is locally completed on all channels, then any blocking of an interpreted channel of P in Q is transformed into the refusal of its whole alphabet in P ; moreover, the refusals on the uninterpreted channels in Q should be matched in 4.1 Realisability and compositionality A direct comparison of an implementation process Q with the corresponding base process P is only possible if there is no di#erence in the communication interfaces, and all communication is interpreted in exactly the same way.
Thus CTS is an ambiguous Relating Communicating Processes 19 representation of Q w.r.t. the extraction graph EG 2 . Note that the problem is caused by our wish to represent an extraction mapping (from traces to traces) in terms of individually labelled arcs, and so a node in a CTS needs to encode the appropriate history of reaching it from the initial state.
On all the above aspects, the present work significantly extends our previous work [11, 12, 5]: the class of admissible specifications has been enlarged to include any, non-diverging, CSP process; the definition of extraction pattern has been technically improved; and the multiple implementation relation schemes previously proposed have been unified into a single one.
Looking at the general issue of behaviour abstraction, some approaches (e.g., [2]) describe system behaviour by sequences of state tuples with an internal component; they then require that, for every possible state sequence of a correct implementation, there should exist one of the specification such that the two sequences coincide after deleting the internal state component.
