The new mode selector is likely to differ from the original mode selector in two key ways; one is a way in which the original mode selector is richer, and the other is a way in which the new mode selector is richer.
For example, the new mode selector can be invoked when the original program throws an exception, violates a requirement or assertion, deadlocks, or times out (spends too much time attempting to perform some task or waiting for some event), and also when the old mode selector chooses a passive default mode, has low confidence in its choice, or is unable to make a decision.
For example, the programmer can examine situations in which the two mode selectors disagree (particularly if the new mode selector outperforms the old one) and find ways to augment the original by hand.
A router in an ad hoc wireless network may have modes that deal with the failure of a neighboring node (by rebuilding its routing table), that respond to congestion (by dropping pack- ets), that conserve power (by reducing signal strength), or that respond to a denial-of-service attack (by triggering packet filters in neighboring routers).
When applied to low-performing programs (such programs had no high-level modes), the results of program steering also performed equally to the original programs, for the modeling step had been unable to make good generalizations.
The new mode selector was invoked when the program threw an uncaught exception (which would ordinarily cause a crash and possibly a reboot), when the program got caught in a loop (that is, when a timeout occurred while waiting for an event, or when the program executed the same actions repeatedly without effect), and additionally at moments chosen at random (if the same mode was chosen, execution was not interrupted, which is a better approach than forcing the mode to be exited and then re-entered).
As a simple example, after picking up ore, the robot might always return to base - even if the robot had the capacity to pick up more ore along the way, or even if it encountered a vulnerable enemy robot.
Program steering generalizes from observations of training runs on which the software behaved well, and produces a new mode selector that, given a concrete program state, selects the mode whose past executions were most similar to the given state.
