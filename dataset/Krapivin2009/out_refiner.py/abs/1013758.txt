That is, the aim was not merely to express polynomial time computability in terms of provability of certain restricted formulas, but rather to provide a typed logical system in which computation via cut-elimination or proof normalization is inherently polytime.
For deeper foundational purposes, we should mention Girard's Light Linear Logic (LLL) [4] as a major improvement of the syntax of BLL, in that it eliminates the explicit polynomial I/O size-bounds, but at the expense of introducing more subtle typing distinctions.
In this paper, we give a direct, semantic proof of this main result which does not involve any notion of reduction, term rewriting, or cut-elimination.
Our proof is constructive, in the sense that it can be formalized in an extensional version of the Calculus of Inductive Constructions [2].
However, unlike Goerdt's system which is a finite model interpretation of G-odel's system T -hence the successor function is not injective- BLL supports the usual semantics, including Peano's axioms, thus can be seen as a meaning-preserving annotation to standard functional programming.
There exists a function e : V(X) # a such that e(#) is computable in time q(#) for some resource polynomial q and for each # V(X), t # a , a # |A|, we have #, t || A a #, e(#)t || B f(a) (1) In this case we say that e witnesses f and write A f e in the notation the algorithm e is presumed to exist.
The following lemma illustrates how realizability sets model the syntactical iteration lemma for BLL (cf. Lemma 6.2 of [3]).
We notice that the forgetful functor B(X) # Set is also monoidal closed, i.e. sends# to - and -# to #. Definition 4.14 Given a polynomial p # P(X) and a realizability set A over X#{x} where then we define a realizability set ! x<p A over X (i.e. x is "bound" by ! x<p ) by . |! x<p . #, t || ! x<pA a if a for each i < p(#).
