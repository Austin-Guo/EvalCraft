If we choose BVal to be empty then we get the recursive type of [2]: and if we consider a variant of object calculus without fields then we get the most simple recursive type which strongly reminds one of call-by-value lambda calculus as given by the type equation L*L.
For the sake of simplicity, in this paper we will use the last domain equation to interpret the functional object- calculus which fits with the convention that in the calculus we do not distinguish between method and field update.
From well-known work of Freyd and Pitts in the early nineties we know that the bifree solutions of the domain equation can be characterised by the requirement that id A is the least fixpoint of In case of F (X; Y which is defined explicitly as the endo-function on [O*O] as given by or, equivalently, in a more readable form by for e: O*O, a2O and m2M.
If we interpret all these predicates denotationally it follows from Theorem 4.4 that they give rise to a unique predicate that is as in Definition 3.3 and serves as the denotational interpretation of S.
This definition satisfies condition (iii) of Theorem 4.4 since if e v id and e(oe):':n w oe 0 :':n then by transitivity from oe:':n w e(oe):':n w oe 0 :':n w e(oe 0 ):':n it follows that To which forms of transition specifications our existence theorem applies remains to be clarified.
Before showing that particular object specifications do not exist we prove the following auxiliary lemma that deals with transition specifications that may also refer to the non flat part of the store, i.e. to some method closures.
To give an example of a non-existing object specifica- tion, we will exhibit a transition specification Tm , a location and a store oe such that there does not exist S ' Loc\ThetaSt satisfying For such a specification the restrictive assumption of Theorem 4.5 - that Tm must only refer to the flat part of the store, i.e. no specifications of past or future behaviour of methods can be made - must necessarily be violated, but also condition (iii) from Theorem 4.4 cannot hold.
Recursive methods can be programmed in the object calculus without explicit recursion due to the recursive higher-order definition of the underlying store.
