Our handling of XML data manipulation consists of two parts: (1) a mapping from XML Schema to the type system of Promela, and (2) a translation algorithm which generates Promela code for an XPath expression.
XML documents can be modeled as trees where each internal node corresponds to a tag and leaf nodes correspond to basic type values.
If we apply the exact operator to the XML tree in part (c) of Fig. 1, we get the XML tree sequence X { investorID, VIP01, requestList, stockID, 0001, stockID, 0002, payment, accountNum, 0425 } Note that, the tree sequence X # can be split at 3 and 8, and there exists a 3-split for X # . 2.2 XML Schema and MSL XML provides a standard way to exchange data over the Inter- net.
However, the parties that exchange XML documents still have to agree on the type of the data, i.e., what are the tags that will appear in the document, in what order, etc. XML Schema [23] is a language for defining XML data types.
Here g, g0 , g1 , . , gk represent MSL types, b is a basic data type such as string, integer or boolean, t is a tag, and m and n are two positive integers where m # n. Intuitively, the semantics of the above MSL type expressions can be summarized as follows: t[g0] denotes a type with a root node labeled with t and children with types that match the sequence of MSL types represented by g0 ; g1{m,n} denotes a sequence of size at least m and at most n where each member is of type g1 ; g1, . ,gk denotes an ordered sequence where the first member is of type g1 , the second member is of type g2 , and so on; and, g1| .
For example, the boolean XPath expression shown in Equation 2 corresponds to the whole Promela code in Fig. 4, its right hand side corresponds to the whole code with lines 51 to 57 left blank, and the left hand side corresponds to an "empty" statement since no code is generated for it.
For each macro, the input node characterizes the starting node where the macro starts search- ing, and the output node is the starting point of its embedment.
The normal mode is for the first time the last() call is encountered; in the copy mode the last() is encountered for a second time when the pre-calculation code is being generated; the processed mode is the case where the value for the last() call has been pre-calculated and this value should not be changed any more.
