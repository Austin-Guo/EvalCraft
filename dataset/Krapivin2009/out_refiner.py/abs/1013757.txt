This is backed up by Cobham's [4] characterization of FP, the functions computable in polynomial time, by a scheme of recursion on notation that is nothing more than an explicitly bounded version of primitive recursion itself (formulated for binary words).
Further, the work of Bellantoni and Cook [3] and Report date: 24 Oct. 2000 Leivant [6] provides primitive recursive schemes for dening FP with no explicit bounds of any rather controlling the primitive recursion by semantically-inspired, syntactically implemented tiering notions.
Thus not only does the approach of implicit computational complexity provide a straightforward way to generalize polynomial-time computable functions to a broader class that ought to correspond to the partial recursive functions, it in fact gives a resource-free characterization of a previously- dened class that asserts to play the same role, thus justifying the naturality of (what turns out to be) the single class considered.
In particular, when a function is dened by recurrence as the denition only makes sense when g is dened no matter what its third argument is|in other words, the denition assumes the totality of f , and hence the domain of denition, and so this argument must be of tier 0.
Furthermore, we note that if we add an unbounded, total minimization operator to primitive recursion, then it is easy to show that the functions denable with applications are exactly those recursive in a (for a proof, one can simply remove the bounds from Bellantoni's proof of the bounded version).
This is proved by induction on the denition of f and is essentially the same as the proof that the functions dened by safe recursion (no minimization) are all polymax bounded.
The polymax bound on f given by Lemma 8 gives a p-time computable bound on the recursion, and so the recursion can be dened in C.
Leivant also shows there that simultaneous safe recursion is reducible to safe recursion, so we can without loss of generality assume we use the latter.
