Adaptive Web Caching [14] builds a mesh of overlapping multicast trees; the popular files are pulled down towards their users from their origin server.
We focus on a class of networks called hierarchical networks, the precise definition of which is given in Section 2, and we call the cooperative caching problem in such networks the hierarchical cooperative caching (HCC) problem.
A shows a result that, given O(d) capacity blowup, where d is the depth of the hierarchy (i.e., n)), an LRU-like online algorithm is constant-competitive.
Notation Meaning #.parent the parent of # #.anc the ancestors of # #.desc the descendants of # #.depth the depth of # #.diam the diameter of # #.files #.cap the total capacity (with no blowup) of the caches in # #.ch children hierarchies of # #.placed the set of (distinct) files placed in the caches in # by ON #.load the number of files f in #.placed such that the depth of f is less than #.depth #.missing the set of files f such that the depth of f is #.depth but f / #.placed #.act g(#.depth , r), where the "activation" value #.react g(#.depth , k), the "reactivation" value #.deact g(#.depth , 2k), the "deactivation" value  Table  1: Key notations.
We next show that every line of code out of the down loop preserves I1 #I2 (i.e., if I1 # I2 holds before the line, then it holds after the line) and every line of code in the down loop preserves I1 #I2 #I3 .
In this section, we show that there exists an o#ine HCC algorithm OFF that serves the sequence of requests generated by ADV and incurs a cost that is a log d less than that incurred by any b-feasible online HCC algorithm.
For any placement P and any pair of siblings # and #, we define swapp(P, #) (swap placement) as the placement obtained from P by exchanging the contents of each cache in # with that of the corresponding cache in #.
By the definition of t, no child of # has been set to 0 since time t. By Lemma 3.1, every internal node has at least one child with x equal to 0.
