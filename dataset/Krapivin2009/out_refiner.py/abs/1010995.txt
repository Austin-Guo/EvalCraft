Our approach could be added to this list, probably with the dierence that we use the knowledge of the occurring design patterns used in the Erlang code to obtain smaller state spaces (cf. [2]).
Clients and locker are implemented as Erlang processes that communicate with each other by message passing.
The ow of control between clients and locker should be as follows: { a client requests the locker an exclusive lock on several resources, { if all requested resources are available, the locker gives an ok to the client, { when the client has performed the necessary operations on the resources, it noties the locker by a release of the locks.
The Erlang processes coincide with the CRL processes, where a non-terminating Erlang function describes the main loop of the process in the Erlang case.
The unique process identiers used in Erlang are integrated as an argument (Self) of all process calls and instantiated by the rst call in the initial part.
The safety properties are easier to check than the liveness properties, as is explained later and depends on the fact that some innite traces in the specication are excluded in a real Erlang execution because of the underlying Erlang scheduler.
Advantage of using this tool compared to the model checking approach are the possibility of using the full -calculus (instead of alternation free), the possibility to reason over an unbounded number of clients and resources, and the completeness of the approach, i.e., if a proof is given, it holds for the program and not only for the specication.
We would like to thank Radu Mateescu and Hubert Garavel from INRIA Rhone- Alpes, Izak van Langevelde, Jaco van de Pol and Wan Fokkink from CWI, and Lars-  Ake Fredlund and Dilian Gurov from SICS for taking part in the discussions on this case study and supporting us with their advises.
