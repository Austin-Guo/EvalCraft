For the sake of simplicity, in this paper we will use the last domain equation to interpret the functional object- calculus which fits with the convention that in the calculus we do not distinguish between method and field update.
Thus, in order to prove that one 'simply' has to exhibit a predicate P with Such a notion of "invariant" specification seems to be quite in accordance with the "coalgebraic view" of the object-oriented world and, therefore, is probably quite use- ful.
However, despite their indisputable usefulness the problem with specifications is that there is no obvious reason why they should exist as the right hand side of the equivalence characterising contains both positive and negative occurrences of Spec(A; ~ Though in [2] specifications are used intrinsically their existence is not verified.
The object formation rule of loc.cit. says about the newly created object specifies the actual memory allocation and the absence of side effects.
This means that the specifications Spec can not only describe denotationally properties of objects at a certain point in a program (like in Abadi& Leino) but a kind of invariant that can be seen as a definition of a "class specification" in the object calculus.
A sensible requirement in presence of method update is that a method is not altered by another method, i.e. a method n can at most become less or equally defined by execution of m (less since we are dealing with partial correctness).
To give an example of a non-existing object specifica- tion, we will exhibit a transition specification Tm , a location and a store oe such that there does not exist S ' Loc\ThetaSt satisfying For such a specification the restrictive assumption of Theorem 4.5 - that Tm must only refer to the flat part of the store, i.e. no specifications of past or future behaviour of methods can be made - must necessarily be violated, but also condition (iii) from Theorem 4.4 cannot hold.
Recursive methods can be programmed in the object calculus without explicit recursion due to the recursive higher-order definition of the underlying store.
