Adaptive Web Caching [14] builds a mesh of overlapping multicast trees; the popular files are pulled down towards their users from their origin server.
In this paper, we study the placement problem, and we assume that a separate mechanism enables a cache to locate a nearest copy of a file, free of cost, and we assume that files are read-only (i.e., copies of a file are always consistent).
If the access frequency of each file at each cache is known in advance, Korupolu et al. [9] have provided both exact and approximation algorithms that minimize the average retrieval cost.
Most existing work on these problems focuses on upper bound results, and lower bound results only apply to algorithms without a capacity blowup.
In this game, OFF maintains a compact placement of files tailored for the request sequence that ADV generates, while ON is forced to guess OFF's placement and incurs relocation costs if it guesses incorrectly.
Notation Meaning #.parent the parent of # #.anc the ancestors of # #.desc the descendants of # #.depth the depth of # #.diam the diameter of # #.files #.cap the total capacity (with no blowup) of the caches in # #.ch children hierarchies of # #.placed the set of (distinct) files placed in the caches in # by ON #.load the number of files f in #.placed such that the depth of f is less than #.depth #.missing the set of files f such that the depth of f is #.depth but f / #.placed #.act g(#.depth , r), where the "activation" value #.react g(#.depth , k), the "reactivation" value #.deact g(#.depth , 2k), the "deactivation" value  Table  1: Key notations.
Lines 4 and 12 preserve the claim because the x fields of the children of # all become preserves the claim (for #.parent ) because #.x becomes #.act , which by definition equals g(i +1, k - j), where and j equals the number of children of #.parent that have a positive x field.
By the definition of t, no child of # has been set to 0 since time t. By Lemma 3.1, every internal node has at least one child with x equal to 0.
