The longer a regression error persists without being caught, the larger its drain on pro- ductivity: when the error is found, more code changes must be considered to find the changes that directly pertain to the error, the code changes are no longer fresh in the developer's mind, and new code written in the meanwhile may also need to be changed as part of the bug fix.
It supports assertions for checking expected results, organizing test cases into hierarchical suites, running a suite, and presenting results textually or graphically.
This text indicates the following states: the code cannot be compiled; regression errors have been introduced (tests that used to give correct answers no longer do); some tests are unimplemented (the tests have never completed correctly).
Years programming 2.8 2.9 0.5 14.0 Years Java programming 0.4 0.5 0.0 2.0 Years using Emacs 1.3 1.2 0.0 5.0 Years using a Java IDE 0.2 0.3 Frequencies Usual environment Unix 29%; Win 38%; both 33% Regression testing familiar 33%; not familiar 67% Used Emacs to compile at least once 62%; never 38% Used Emacs for Java at least once 17%; never 83%  Figure  1: Study participant demographics (N=22).
When comparing nominal (also known as classification or cate- gorical) variables, we used the Chi-Square test, except that we used Fisher's exact test (a more conservative test) when 20% or more of the the cells of the classification table had expected counts less than 5, because Chi-Square is not valid in such circumstances.
The mean frequency for manual testing (see Figure 5) among those who tested throughout was once every 20 minutes, which is longer than the mean time to pass an additional test during development possibly indicating that students were often writing code to pass several tests at a time before running the tests to confirm.
Our experiment has produced statistically significant results showing that for student developers using a test-first methodology, a continuous compilation tool doubles the success rate in creating a correct program, and a continuous testing tool triples the success rate.
Software tomography [22] partitions a monitoring task (such as testing [21]) into many small subpieces that are distributed to multiple sites; for instance, testing might be performed at client sites.
