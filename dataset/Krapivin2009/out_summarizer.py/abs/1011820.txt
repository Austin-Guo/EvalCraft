INTRODUCTION Group Key Exchange (GKE) protocols allow a group of servers communicating over a complete network of point-to- point links to establish a common session key such that anyone outside the group that can only observe the network traffic Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page.
One way to solve this problem, explored by Amir et al. [2], is to base GKE on a view-based group communication system (GCS), which provides the abstraction of the "currently live nodes" to all servers in a consistent way (Chockler et al. [15] provide a survey of GCS).
Since the GCS can detect crashes among the servers also during the execution of a GKE proto- col, the protocol can react accordingly; as GCSs rely on time-outs to detect crashed participants, the approach leads to solutions that are not purely asynchronous and subject to timing attacks, however.
Along the first dimension, one can distinguish between GKE protocols that assume an authentic network (as we do) [19, 8, 26, 24, 27], and GKE protocols that rely on a-priori distributed public and private keys (as for example provided by a public-key recent paper of Katz and Yung [21] closes the bridge between these two approaches by showing how any GKE protocol built for an authentic network can be "compiled" into a GKE protocol for an insecure net-work with a-priori distributed public and private keys.
In case that the GCS detects nested leaves, i.e., detects leaving servers during the execution of a (dynamic) GKE protocol, this protocol is aborted and a basic GKE protocol is run from scratch among the remaining servers.
In the first case, we assign round number 0 to m, and in the second case, we assign round number r + 1 to m, where r is the round number of m 0 . Let R H;A real () denote an upper bound on the expected highest round number assigned to a message in a run of Sys real; configured with H and A real , where the expectation is taken over the random choices of the servers.
Decide: When TH cons receives (decide; ID;i;v) from the ad- versary, it verifies (by consulting P [ID] and -[ID ]) that server i has proposed some value for ID at least one server proposed v for ID no other server has decided another value for ID If all checks succeed, it sets -[ID] v, and outputs (decide; ID; v) to the user at out i .
By the assumption that at most tc servers crash, it follows that every server in U receives n tc contribution values y j and proposes some values for ID jcs.
