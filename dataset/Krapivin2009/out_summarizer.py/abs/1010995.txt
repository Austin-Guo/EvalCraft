Basically there are two branches, either one uses a spec- ication language in combination with a model checker to obtain a correct spec- ication that is used to write an implementation in a programming language, or one takes the program code as a starting point and abstracts from that into a model, which can be checked by a model checker.
Our approach could be added to this list, probably with the dierence that we use the knowledge of the occurring design patterns used in the Erlang code to obtain smaller state spaces (cf. [2]).
When, in the above example, client 2 is given access and client 1 requests both resources again, then by the time client 2 releases, client 1 will be granted access.
The different clauses of the handle call function are combined in one CRL loop, using the state mentioned in the arguments of handle call as state of the loop.
In order to perform several verications at once, in particular to verify all situations in which the clients repeatedly request an arbitrary (varying) subset of the resources, we modied the CRL specication by hand.
For a system with two resources, r 1 and r 2 , the mutual exclusion property is formalized by A new version of the model checking tool within the Csar/Ald ebaran toolset [9] is under construction and with this new release, we should be able to formulate one property for an arbitrary number of resources.
Advantage of using this tool compared to the model checking approach are the possibility of using the full -calculus (instead of alternation free), the possibility to reason over an unbounded number of clients and resources, and the completeness of the approach, i.e., if a proof is given, it holds for the program and not only for the specication.
We would like to thank Radu Mateescu and Hubert Garavel from INRIA Rhone- Alpes, Izak van Langevelde, Jaco van de Pol and Wan Fokkink from CWI, and Lars-  Ake Fredlund and Dilian Gurov from SICS for taking part in the discussions on this case study and supporting us with their advises.
