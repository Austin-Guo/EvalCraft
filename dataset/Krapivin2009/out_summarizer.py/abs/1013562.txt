In the case of XML, it would be more accurate to consider strings labeled by a finite alphabet and attach data values to positions in the # A preliminary version with title Towards regular language over infinite alphabets appeared in the proceedings of the 26th International Symposium on Mathematical Foundations of Computer Science (MFCS 2001), Czech Republic, 2001.
This author supported in part by the National Science Foundation under grant number IIS-9802288.
We point out that the pebbling mechanism we employ is based on the one of Milo, Suciu, and Vianu [18] and is more liberal than the one used by Globerman and Harel [9]: indeed, in our case, after a pebble is placed the automaton can still walk over the whole string and sense the presence of the other pebbles.
A run of A on w is a tree where nodes are labeled with configurations as follows: 1. the root is labeled with the initial configuration; 2. every inner node labeled with an existential configuration # has exactly one child # and # ; and, 3. every inner node labeled with a universal configuration # has children labeled with An accepting run is a run where every leaf node is labeled with a final configuration.
A language is accepted by a protocol if for each string both parties can decide after execution of the protocol whether the string belongs to the language.
This problem is hard for nlogspace.
Furthermore, we enumerate the states in Q such that We consider first the case when A uses a single pebble, to illustrate how one encodes the state in a configuration and how to encode the transitions.
By virtually adding two steps we view an accepting computation as consisting of (1) a first step in which the first pebble is placed at the first position, (2) a computation in which always at least one pebble is present, and (3) a final step in which the only remaining pebble is removed.
